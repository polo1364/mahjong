<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Âè∞ÁÅ£16ÂºµÈ∫ªÂ∞áÔºàÊòéÊòü3Áº∫1Ë¶èÂâáÔΩúÂñÆÊ©üÔºâ</title>
<style>
* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: system-ui, -apple-system, "Noto Sans TC", "Microsoft JhengHei", sans-serif;
  background: linear-gradient(135deg, #0a1628 0%, #1a2f4a 100%);
  color: #e9f0f6;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  overflow-x: hidden;
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: linear-gradient(180deg, #0e1b2a 0%, #1a2838 100%);
  border-bottom: 2px solid #2a4766;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  position: sticky;
  top: 0;
  z-index: 100;
  flex-wrap: wrap;
  gap: 8px;
}

.row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.pill {
  background: linear-gradient(135deg, #1a3a5a 0%, #0f2438 100%);
  border: 1px solid #2b4766;
  border-radius: 999px;
  padding: 6px 12px;
  font-size: 13px;
  white-space: nowrap;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

button {
  cursor: pointer;
  background: linear-gradient(135deg, #2d5a8a 0%, #1d3a57 100%);
  border: 1px solid #3c6d9c;
  color: #e9f0f6;
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  box-shadow: 0 3px 8px rgba(0,0,0,0.3);
}

button:hover:not(:disabled) {
  background: linear-gradient(135deg, #3d6a9a 0%, #2d4a67 100%);
  transform: translateY(-1px);
  box-shadow: 0 5px 12px rgba(0,0,0,0.4);
}

button:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

#newGameBtn {
  background: linear-gradient(135deg, #d4a574 0%, #b8894e 100%);
  border-color: #e0b888;
  color: #1a1a1a;
}

#newGameBtn:hover {
  background: linear-gradient(135deg, #e4b584 0%, #c8995e 100%);
}

#table {
  max-width: 1200px;
  margin: 16px auto;
  padding: 0 12px;
}

.score {
  background: linear-gradient(135deg, #0e1b2a 0%, #1a2838 100%);
  border: 1px solid #2a4766;
  border-radius: 12px;
  padding: 14px;
  margin-bottom: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.score h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  color: #ffd36f;
}

.hand {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 8px;
  justify-content: center;
}

.tile {
  cursor: pointer;
  border: 2px solid #4a6d8c;
  background: linear-gradient(180deg, #ffffff 0%, #f0f8ff 100%);
  color: #1a2634;
  border-radius: 10px;
  padding: 10px 8px;
  min-width: 44px;
  text-align: center;
  font-weight: 700;
  font-size: 16px;
  transition: all 0.2s ease;
  box-shadow: 0 3px 6px rgba(0,0,0,0.2), inset 0 1px 2px rgba(255,255,255,0.5);
  position: relative;
  user-select: none;
}

.tile:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.7);
  border-color: #6a8dac;
}

.tile:active {
  transform: translateY(-2px);
}

.tile.gold {
  background: linear-gradient(180deg, #ffd700 0%, #ffed4e 100%);
  border-color: #d4af37;
  box-shadow: 0 3px 8px rgba(255, 215, 0, 0.4), inset 0 1px 2px rgba(255,255,255,0.6);
  animation: goldGlow 2s ease-in-out infinite;
}

@keyframes goldGlow {
  0%, 100% { box-shadow: 0 3px 8px rgba(255, 215, 0, 0.4), inset 0 1px 2px rgba(255,255,255,0.6); }
  50% { box-shadow: 0 3px 12px rgba(255, 215, 0, 0.7), inset 0 1px 2px rgba(255,255,255,0.8); }
}

.tile.dim {
  opacity: 0.6;
  filter: grayscale(0.3);
}

.tile.ai {
  background: linear-gradient(180deg, #e0e8f0 0%, #d0dce8 100%);
  font-size: 14px;
  min-width: 36px;
  padding: 8px 6px;
}

/* ‰∏çÂêåËä±Ëâ≤ÁöÑÁâåÈù¢È°èËâ≤ */
.tile.suit-W {
  background: linear-gradient(180deg, #ffe5e5 0%, #ffcccc 100%);
  border-color: #cc6666;
  color: #cc0000;
}

.tile.suit-T {
  background: linear-gradient(180deg, #e5f0ff 0%, #cce0ff 100%);
  border-color: #6699cc;
  color: #0066cc;
}

.tile.suit-B {
  background: linear-gradient(180deg, #e5ffe5 0%, #ccffcc 100%);
  border-color: #66cc66;
  color: #009900;
}

.tile.suit-F, .tile.suit-D {
  background: linear-gradient(180deg, #fff5e5 0%, #ffe5cc 100%);
  border-color: #cc9966;
  color: #cc6600;
  font-weight: 800;
}

.tile.suit-H {
  background: linear-gradient(180deg, #ffe5ff 0%, #ffccff 100%);
  border-color: #cc66cc;
  color: #cc00cc;
}

.hand {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  margin: 12px 0;
}

.meld {
  background: linear-gradient(135deg, #1a3a5a 0%, #0f2438 100%);
  border: 2px dashed #4a6d8c;
  border-radius: 8px;
  padding: 6px 10px;
  margin-right: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.sec {
  margin: 20px 0;
}

.sec h3 {
  color: #ffd36f;
  margin: 0 0 10px 0;
  font-size: 18px;
  display: flex;
  align-items: center;
  gap: 8px;
}

#log {
  background: linear-gradient(135deg, #0a1520 0%, #0e1b2a 100%);
  border: 1px solid #2a4766;
  border-radius: 10px;
  padding: 12px;
  height: 180px;
  overflow-y: auto;
  font-size: 13px;
  white-space: pre-wrap;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3);
  line-height: 1.6;
}

#log::-webkit-scrollbar {
  width: 8px;
}

#log::-webkit-scrollbar-track {
  background: #0a1520;
  border-radius: 4px;
}

#log::-webkit-scrollbar-thumb {
  background: #2a4766;
  border-radius: 4px;
}

#log::-webkit-scrollbar-thumb:hover {
  background: #3a5776;
}

#controls {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 12px;
  justify-content: center;
}

.badge {
  padding: 4px 10px;
  border-radius: 6px;
  background: linear-gradient(135deg, #2a4766 0%, #1a3756 100%);
  border: 1px solid #3a5776;
  font-size: 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.you {
  color: #ffd36f;
  font-weight: 700;
}

.dealer {
  border: 3px solid #ffcf4e !important;
  box-shadow: 0 0 12px rgba(255, 207, 78, 0.5);
}

.danger {
  color: #ff8a8a;
  font-weight: 700;
}

.ok {
  color: #9cf39c;
  font-weight: 700;
}

#goldbar {
  background: linear-gradient(135deg, #2a3a1a 0%, #1a2a0a 100%);
  border: 2px solid #4a6d2c;
  border-radius: 10px;
  padding: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

#goldbar .tilekey {
  display: inline-block;
  margin-right: 8px;
  padding: 4px 10px;
  border-radius: 8px;
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
  border: 2px solid #d4af37;
  color: #1a1a1a;
  font-weight: 700;
  box-shadow: 0 2px 6px rgba(255, 215, 0, 0.4);
}

.player-info {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  align-items: center;
  padding: 8px;
  background: linear-gradient(135deg, #1a2838 0%, #0e1b2a 100%);
  border-radius: 8px;
  margin-bottom: 6px;
}

.player-name {
  font-weight: 700;
  font-size: 15px;
}

.player-points {
  font-weight: 700;
  font-size: 16px;
  color: #9cf39c;
}

.reaction-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(135deg, #1a2838 0%, #0e1b2a 100%);
  border: 3px solid #ffd36f;
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6);
  z-index: 200;
  min-width: 280px;
  text-align: center;
}

.reaction-panel h3 {
  margin: 0 0 16px 0;
  color: #ffd36f;
  font-size: 20px;
}

.reaction-panel .row {
  justify-content: center;
  margin-top: 12px;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 199;
}

/* ÊâãÊ©üÈüøÊáâÂºèË®≠Ë®à */
@media (max-width: 768px) {
  header {
    padding: 10px 12px;
  }
  
  .pill {
    font-size: 11px;
    padding: 4px 8px;
  }
  
  .tile {
    min-width: 38px;
    padding: 7px 5px;
    font-size: 14px;
  }
  
  .tile-drawn {
    margin-left: 10px;
  }
  
  button {
    padding: 8px 12px;
    font-size: 13px;
  }
  
  #table {
    padding: 0 8px;
  }
  
  .tile {
    min-width: 38px;
    padding: 8px 6px;
    font-size: 14px;
  }
  
  .tile.ai {
    min-width: 32px;
    padding: 6px 4px;
    font-size: 12px;
  }
  
  .hand {
    gap: 4px;
  }
  
  .sec h3 {
    font-size: 16px;
  }
  
  #log {
    height: 140px;
    font-size: 12px;
  }
  
  .score {
    padding: 10px;
  }
}

@media (max-width: 480px) {
  .tile {
    min-width: 32px;
    padding: 6px 4px;
    font-size: 13px;
  }
  
  .tile-drawn {
    margin-left: 8px;
  }
  
  .hand-row {
    gap: 4px;
  }
  
  .tile.ai {
    min-width: 28px;
    padding: 5px 3px;
    font-size: 11px;
  }
  
  .hand {
    gap: 3px;
  }
  
  #controls {
    gap: 6px;
  }
  
  button {
    padding: 6px 10px;
    font-size: 12px;
  }
}

/* ÊâãÁâåÂÆπÂô®Ê®£Âºè */
.hand-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
  margin: 12px 0;
}

.hand-row {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: center;
}

.tile {
  min-width: 42px;
  padding: 8px 6px;
  background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
  border: 2px solid #ccc;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  user-select: none;
}

.tile:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.25);
}

.tile-drawn {
  margin-left: 12px;
  border: 3px solid #ffd36f;
  box-shadow: 0 0 12px rgba(255, 211, 111, 0.6), 0 2px 4px rgba(0,0,0,0.15);
}

/* ÂãïÁï´ÊïàÊûú */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.tile {
  animation: slideIn 0.3s ease;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

.tile:hover {
  animation: pulse 0.5s ease infinite;
}
</style>
</head>
<body>
<header>
  <div class="row">
    <span class="pill">üÄÑ Âè∞ÁÅ£ 16 ÂºµÔΩúÊòéÊòü 3 Áº∫ 1ÔºàÂñÆÊ©üÔºâ</span>
    <label class="pill" style="cursor: pointer;">
      <input id="goldSwitch" type="checkbox" checked style="margin-right: 4px;"> ÂïüÁî®ÈáëÁâå
    </label>
    <span class="pill">üí∞ Â∫ï 50ÔºèÊØèÂè∞ 100</span>
    <span class="pill">üéØ Ëµ∑Âßã 100,000</span>
  </div>
  <div class="row">
    <button id="newGameBtn">üé≤ ÈñãÂßãÊñ∞Â±Ä</button>
  </div>
</header>

<div id="table">
  <div id="scoreboard"></div>
  <div class="row sec" id="goldbar"></div>

  <div class="sec">
    <h3>üìä Â±ÄÈù¢Ë≥áË®ä</h3>
    <div id="roundinfo" class="row"></div>
  </div>

  <div class="sec">
    <h3>üé¥ ‰Ω†ÁöÑÊâãÁâå <span class="badge">ÈªûÊìäË¶ÅÊâìÂá∫ÁöÑÁâå</span></h3>
    <div id="yourHand" class="hand"></div>
    <div id="yourMelds" class="row" style="justify-content: center; margin-top: 8px;"></div>
    <div id="controls" class="row">
      <button id="btnHu" disabled>üéâ ËÉ°Áâå</button>
      <button id="btnChow" disabled>üçú ÂêÉ</button>
      <button id="btnPong" disabled>üî• Á¢∞</button>
      <button id="btnKong" disabled>üí• Êßì</button>
      <button id="btnListen" disabled>üîî ËÅΩ</button>
      <button id="btnPass" disabled>‚è≠Ô∏è ÈÅé</button>
    </div>
  </div>

  <div class="sec">
    <h3>üë• ÂÖ∂‰ªñÁé©ÂÆ∂</h3>
    <div id="others"></div>
  </div>

  <div class="sec">
    <h3>üìú Êà∞Ê≥ÅË®òÈåÑ</h3>
    <div id="log"></div>
  </div>
</div>

<div id="reactionPanel" style="display: none;"></div>
<div id="overlay" class="overlay" style="display: none;"></div>

<script>
/* ========= Âü∫Êú¨Â∑•ÂÖ∑ ========= */
const rng = (n) => Math.floor(Math.random() * n);
const clone = (o) => JSON.parse(JSON.stringify(o));

function log(msg) {
  const el = document.getElementById('log');
  const time = new Date().toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  el.textContent += `[${time}] ${msg}\n`;
  el.scrollTop = el.scrollHeight;
}

/* ========= ÁâåÂûãÂÆöÁæ© ========= */
const SUIT_W = 'W', SUIT_T = 'T', SUIT_B = 'B', SUIT_F = 'F', SUIT_D = 'D';
const WINDS = ['E', 'S', 'W', 'N'];
const DRAGONS = ['C', 'F', 'B'];
// Ëä±ÁâåÂ∑≤ÁßªÈô§

function tileKey(t) {
  if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) return t.suit + String(t.rank);
  if (t.suit === SUIT_F || t.suit === SUIT_D) return t.suit + t.name;
  return '?';
}

function keyToText(k) {
  const s = k[0], v = k.slice(1);
  if (s === SUIT_W) return v + 'Ëê¨';
  if (s === SUIT_T) return v + 'Á≠í';
  if (s === SUIT_B) return v + 'Ê¢ù';
  if (s === SUIT_F) {
    const m = { E: 'Êù±', S: 'Âçó', W: 'Ë•ø', N: 'Âåó' };
    return m[v] || k;
  }
  if (s === SUIT_D) {
    const m = { C: '‰∏≠', F: 'Áôº', B: 'ÁôΩ' };
    return m[v] || k;
  }
  return k;
}

function generateTiles() {
  const tiles = [];
  const push4 = (suit, rank) => {
    for (let i = 0; i < 4; i++) tiles.push({ suit, rank, id: tiles.length });
  };
  for (let r = 1; r <= 9; r++) {
    push4(SUIT_W, r);
    push4(SUIT_T, r);
    push4(SUIT_B, r);
  }
  WINDS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_F, name: n, id: tiles.length });
  });
  DRAGONS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_D, name: n, id: tiles.length });
  });
  // Ëä±ÁâåÂ∑≤ÁßªÈô§ÔºåÁ∏ΩÁâåÊï∏136Âºµ
  return tiles;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = rng(i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ========= ÈÅäÊà≤Ë¶èÂâáËàáÁãÄÊÖã ========= */
const RULES = {
  handSize: 16,
  gold: { enabled: true, initial: 3, maxExtra: 2, totalMax: 5, perGold: 1, winOnGold: 3 },
  scoring: {
    SelfDraw: 1,
    MenqingSelfDraw: 3,
    AllPungs: 2,
    SevenPairs: 4,
    HalfFlush: 3,
    PureOneSuit: 5,
    Flower: 1,
    Wind: 1,
    RobKong: 1,
    Rinshan: 1,
    Haitei: 1
    ,
    // Âú∞ËÅΩÔºöËµ∑ÁâåÂæåÊµ∑Â∫ïÊâìÈÄ≤8ÂºµÁâåÂÖß‰∏îÁÑ°‰∫∫ÂêÉÁ¢∞ÊôÇÂÆ£ÂëäËÅΩÁâå
    EarthReady: 4,
    // Â§©ËÅΩÔºöËéäÂÆ∂Á¨¨‰∏ÄÂºµÊâìÂá∫ÂæåÂç≥ËÅΩÁâå
    HeavenReady: 8
  },
  points: { base: 50, perFan: 100 },
  initialPoints: 100000
};

let S = null;

function startNewHand(isFirstGame = false) {
  const useGold = document.getElementById('goldSwitch').checked;
  
  let newDealer = S?.dealer ?? 0;
  let newRound = S?.round ?? 1;
  
  if (isFirstGame || !S) {
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const diceSum = dice1 + dice2;
    newDealer = (diceSum - 1) % 4;
    newRound = 1;
    log(`üé≤ Êì≤È™∞Ôºö${dice1} + ${dice2} = ${diceSum}ÔºåËéäÂÆ∂ÁÇ∫${['Êù±ÂÆ∂(‰Ω†)', 'ÂçóÂÆ∂', 'Ë•øÂÆ∂', 'ÂåóÂÆ∂'][newDealer]}`);
  } else if (S.winner === null) {
    // ÊµÅÂ±ÄÔºåËéäÂÆ∂ÁπºÁ∫åÁï∂ËéäÔºàÈÄ£ËéäÔºâ
    log(`üîÅ ÊµÅÂ±ÄÈÄ£ËéäÔºåËéäÂÆ∂ÁπºÁ∫åÁï∂Ëéä`);
  } else if (S.winner === S.dealer) {
    // ËéäÂÆ∂ËÉ°ÁâåÔºåÁπºÁ∫åÁï∂ËéäÔºàÈÄ£ËéäÔºâ
    log(`üèÜ ËéäÂÆ∂ËÉ°ÁâåÔºåÁπºÁ∫åÁï∂Ëéä`);
  } else {
    // ÈñëÂÆ∂ËÉ°ÁâåÔºåËéäÂÆ∂Ëº™Êõø
    newDealer = (S.dealer + 1) % 4;
    if (newDealer === 0) {
      newRound++;
      if (newRound > 4) {
        log(`üèÅ ÂõõÂúàÂ∑≤ÊâìÂÆåÔºåÈÅäÊà≤ÁµêÊùüÔºÅ`);
        showFinalScore();
        return;
      }
      log(`üîÑ ÈÄ≤ÂÖ•Á¨¨${newRound}Âúà`);
    }
    log(`üîÅ ËéäÂÆ∂Ëº™ÊõøËá≥${['Êù±ÂÆ∂(‰Ω†)', 'ÂçóÂÆ∂', 'Ë•øÂÆ∂', 'ÂåóÂÆ∂'][newDealer]}`);
  }
  
  S = {
    wall: shuffle(generateTiles()),
    deadWall: [],
    players: Array.from({ length: 4 }, (_, i) => ({
      hand: [],
      melds: [],
      discards: [],
      // Keep flowers array even though flower logic is removed to avoid undefined spread errors
      flowers: [],
      points: (S?.players?.[i]?.points ?? RULES.initialPoints),
      declaredListen: false,
      // Ê®ôË®òÊòØÂê¶ÁÇ∫Â§©ËÅΩÊàñÂú∞ËÅΩÔºåÈ†êË®≠ÁÇ∫Âê¶
      tianTing: false,
      diTing: false,
      isAI: i !== 0,
      rinshan: false
    })),
    goldKeys: [],
    kongCount: 0, // ÊßìÁâåÊ¨°Êï∏ÔºåÊØèÊßì‰∏ÄÊ¨°Êµ∑Â∫ïÂ§ö‰øùÁïô1Âºµ
    rules: clone(RULES),
    turn: newDealer,
    dealer: newDealer,
    round: newRound,
    lastDiscard: null,
    waitReact: null,
    winner: null,
    fromPlayer: null,
    winTile: null,
    phase: 'deal',
    remain: 0,
    // Êë∏ÁâåÊ¨°Êï∏ÔºåÁî®ÊñºÂà§Êñ∑Âú∞ËÅΩ/Â§©ËÅΩ
    drawCount: 0,
    // ÊòØÂê¶Â∑≤ÊúâÁé©ÂÆ∂ÂÅöÂá∫ÊòéÂêÉÁ¢∞ÊßìÔºåËã•ÊúâÂâáÂú∞ËÅΩ‰∏çÂÜçÊàêÁ´ã
    anyOpenMeld: false,
    robKong: false
  };
  S.rules.gold.enabled = useGold;

  dealTiles();
  if (S.rules.gold.enabled) initGoldTiles();
  S.phase = 'play';
  S.remain = S.wall.length;
  renderAll();
  
  const dealerName = ['Êù±ÂÆ∂(‰Ω†)', 'ÂçóÂÆ∂', 'Ë•øÂÆ∂', 'ÂåóÂÆ∂'][S.dealer];
  const roundName = ['Êù±', 'Âçó', 'Ë•ø', 'Âåó'][newRound - 1];
  log(`üéÆ Á¨¨${newRound}Âúà ${roundName}È¢®ÔºåËéäÂÆ∂Ôºö${dealerName}${S.rules.gold.enabled ? 'ÔºåÂïüÁî®ÈáëÁâå' : ''}`);
  
  if (S.dealer === 0) {
    log(`üëâ ËéäÂÆ∂ÊåÅÊúâ17ÂºµÁâåÔºåË´ãÁõ¥Êé•Âá∫Áâå`);
  } else {
    log(`‚è≥ AIËéäÂÆ∂ÈñãÂßãÂá∫Áâå...`);
    setTimeout(stepAI, 800);
  }
}

function dealTiles() {
  const dead = 16; // Êµ∑Â∫ïÁâå16Âºµ
  // ÁôºÁâåÔºöËéäÂÆ∂ÔºàdealerÔºåÂõ∫ÂÆöÁÇ∫0ÔºâÁôº17ÂºµÔºåÂÖ∂‰ªñÁé©ÂÆ∂Áôº16Âºµ
  while (S.wall.length > dead && S.players[0].hand.length < 16) {
    for (let p = 0; p < 4; p++) {
      if (S.wall.length > dead) {
        S.players[p].hand.push(S.wall.pop());
      }
    }
  }
  // ËéäÂÆ∂Â§öÊë∏‰∏ÄÂºµÔºà17ÂºµÔºâ
  if (S.wall.length > dead) {
    S.players[S.dealer].hand.push(S.wall.pop());
  }
  
  // Ë®≠ÂÆöÁéãÁâåÂçÄÔºöÂæûÁâåÂ±±Â∞æÁ´ØÂèñÊúÄÂæé16Âºµ‰ΩúÁÇ∫ÁéãÁâå
  const deadWallSize = Math.min(dead, S.wall.length);
  S.deadWall = S.wall.splice(-deadWallSize, deadWallSize);
}

// Ëä±ÁâåËôïÁêÜÂáΩÊï∏Â∑≤ÂÆåÂÖ®ÁßªÈô§

function processFlowersInHand_DELETED(p) {
  const pl = S.players[p];
  let hasFlower = true;
  
  while (hasFlower) {
    hasFlower = false;
    for (let i = pl.hand.length - 1; i >= 0; i--) {
      if (pl.hand[i].suit === SUIT_H) {
        const flower = pl.hand.splice(i, 1)[0];
        pl.flowers.push(flower);
        log(`üå∏ ${playerName(p)} ÊãøÂà∞Ëä±Ôºà${keyToText(tileKey(flower))}ÔºâÔºåÂæûÁéãÁâåË£úÁâå`);
        
        // ÂæûÁéãÁâåÂ∞æÁ´ØË£úÁâå
        if (S.deadWall.length > 0) {
          const newTile = S.deadWall.pop();
          if (newTile.suit === SUIT_H) {
            // Ë£úÂà∞ÁöÑ‰πüÊòØËä±ÁâåÔºåÁπºÁ∫åËôïÁêÜ
            pl.flowers.push(newTile);
            log(`üå∏ ${playerName(p)} Ë£úÁâåÂèàÊë∏Âà∞Ëä±Ôºà${keyToText(tileKey(newTile))}ÔºâÔºåÂÜçË£úÁâå`);
            hasFlower = true;
          } else {
            pl.hand.push(newTile);
          }
        } else if (S.wall.length > 0) {
          // ÁéãÁâåÁî®ÂÆåÔºåÂæûÁâåÂ±±Ë£ú
          const newTile = S.wall.pop();
          if (newTile.suit === SUIT_H) {
            pl.flowers.push(newTile);
            log(`üå∏ ${playerName(p)} Ë£úÁâåÂèàÊë∏Âà∞Ëä±Ôºà${keyToText(tileKey(newTile))}ÔºâÔºåÂÜçË£úÁâå`);
            hasFlower = true;
          } else {
            pl.hand.push(newTile);
          }
        }
        hasFlower = true;
        break;
      }
    }
  }
}

function drawTile(p) {
  // Ê™¢Êü•ÊòØÂê¶Âà∞ÈÅîÊµ∑Â∫ïÔºö16Âºµ + ÊßìÁâåÊ¨°Êï∏
  const deadWallLimit = 16 + S.kongCount;
  if (S.wall.length <= 0) {
    log(`üö´ ÁâåÂ±±ÊûØÁ´≠ÔºàÂâ©È§ò${S.deadWall.length}ÂºµÊµ∑Â∫ïÁâåÔºâÔºåÊµÅÂ±Ä`);
    S.phase = 'end';
    S.winner = null;
    renderAll();
    setTimeout(() => {
      log('‚Äî‚Äî Èñã‰∏ã‰∏ÄÂ±Ä ‚Äî‚Äî');
      startNewHand();
    }, 2000);
    return;
  }
  // ÈùûÊßìË£úÁâåÊë∏ÁâåÂâçÔºåÈáçÁΩÆÊßì‰∏äÈñãËä±ÊóóÊ®ô
  const pl = S.players[p];
  pl.rinshan = false;
  const t = S.wall.pop();
  // Ë®òÈåÑÊë∏ÁâåÊ¨°Êï∏ÔºöÂÉÖË®àÁÆóÂæûÁâåÂ±±Êë∏ÁâåÔºå‰∏çÂê´Ë£úÁéãÁâå
  S.drawCount++;
  if (false) { // Ëä±ÁâåËôïÁêÜÂ∑≤ÁßªÈô§
    pl.flowers.push(t);
    log(`üå∏ ${playerName(p)} Êë∏Âà∞Ëä±Ôºà${keyToText(tileKey(t))}ÔºâÔºåÂæûÁéãÁâåË£úÁâå`);
    renderAll();
    // Êë∏Âà∞Ëä±ÁâåÔºåÂæûÁéãÁâåË£úÁâå
    if (S.deadWall.length > 0) {
      constË°•Áâå = S.deadWall.pop();
      if (Ë°•Áâå.suit === SUIT_H) {
        // Ë£úÂà∞ÁöÑ‰πüÊòØËä±Áâå
        pl.flowers.push(Ë°•Áâå);
        log(`üå∏ ${playerName(p)} Ë£úÁâåÂèàÊë∏Âà∞Ëä±Ôºà${keyToText(tileKey(Ë°•Áâå))}ÔºâÔºåÂÜçÂæûÁéãÁâåË£úÁâå`);
        renderAll();
        drawFlowerReplacement(p);
      } else {
        pl.hand.push(Ë°•Áâå);
        S.remain = S.wall.length;
        renderAll();
      }
    } else {
      // ÁéãÁâåÁî®ÂÆåÔºåÂæûÁâåÂ±±Ë£ú
      drawFlowerReplacement(p);
    }
    return;
  }
  pl.hand.push(t);
  S.remain = S.wall.length;
}

function drawFlowerReplacement_DELETED(p) {
  // ÈÅûËø¥Ë£úËä±Áâå
  if (!S.wall.length && !S.deadWall.length) {
    log('‚ö†Ô∏è ÁÑ°ÁâåÂèØË£ú');
    renderAll();
    return;
  }
  
  const pl = S.players[p];
  let tile;
  
  if (S.deadWall.length > 0) {
    tile = S.deadWall.pop();
  } else if (S.wall.length > 0) {
    tile = S.wall.pop();
  } else {
    renderAll();
    return;
  }
  
  if (tile.suit === SUIT_H) {
    pl.flowers.push(tile);
    log(`üå∏ ${playerName(p)} Ë£úÁâåÂèàÊë∏Âà∞Ëä±Ôºà${keyToText(tileKey(tile))}ÔºâÔºåÁπºÁ∫åË£úÁâå`);
    renderAll();
    drawFlowerReplacement(p);
  } else {
    pl.hand.push(tile);
    S.remain = S.wall.length;
    renderAll();
  }
}

function initGoldTiles() {
  const candidates = [];
  for (let r = 1; r <= 9; r++) {
    candidates.push('W' + r, 'T' + r, 'B' + r);
  }
  WINDS.forEach(n => candidates.push('F' + n));
  DRAGONS.forEach(n => candidates.push('D' + n));
  while (S.goldKeys.length < 3) {
    const k = candidates[rng(candidates.length)];
    if (!S.goldKeys.includes(k)) S.goldKeys.push(k);
  }
}

function playerName(i) {
  return ['Êù±(‰Ω†)', 'Âçó', 'Ë•ø', 'Âåó'][i];
}

// Ë®àÁÆóÁé©ÂÆ∂Â∑≤Á∂ìÂΩ¢ÊàêÁöÑÊßìÁµÑÊï∏
function countKongs(pl) {
  return pl.melds.filter(m => m.type === 'kong').length;
}

// Ê™¢Êü•‰∏¶Ë®≠ÂÆöÂ§©ËÅΩ/Âú∞ËÅΩÁãÄÊÖã„ÄÇÁï∂Áé©ÂÆ∂ÂÆ£ÂëäËÅΩÁâåÊôÇË™øÁî®„ÄÇ
// Â§©ËÅΩÔºöËéäÂÆ∂Êë∏ÂÆåÁ¨¨‰∏ÄÂºµÁâåÊâìÂá∫ÂæåÂç≥ËôïÊñºËÅΩÁâåÔºå‰∏îÁÑ°ÂÖ∂‰ªñÊòéÂêÉÁ¢∞ÊßìÔºõÂú∞ËÅΩÔºöËµ∑ÁâåÂæåÊµ∑Â∫ïÊâìÈÄ≤8ÂºµÁâåÂÖß‰∏îÂõõÂÆ∂ÁöÜÊú™ÂêÉÁ¢∞ÔºåÂÆ£ÂëäËÅΩÁâå„ÄÇ
function updateTianDiTing(pid) {
  const pl = S.players[pid];
  // Â∑≤ÊúâÈñãÊòéÁâåÂâá‰∏çË®àÂ§©ËÅΩ/Âú∞ËÅΩ
  if (S.anyOpenMeld) return;
  // Â§©ËÅΩÂÉÖÈÅ©Áî®ÊñºËéäÂÆ∂Á¨¨‰∏ÄËº™Êë∏ÊâìÁµêÊùüÂæåÂç≥ËÅΩÁâå
  if (pid === S.dealer && S.drawCount === 1) {
    pl.tianTing = true;
    return;
  }
  // Âú∞ËÅΩÔºöÂâç8Ê¨°Êë∏ÁâåÂÖß
  if (S.drawCount <= 8) {
    pl.diTing = true;
  }
}

/* ========= ËÉ°ÁâåÂà§ÂÆö ========= */
function isWinningNow(hand, melds, winTile) {
  const tiles = hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
  // Ëã•Ê≤íÊúâ‰ªª‰ΩïÂâØÈú≤Ôºå‰∏îÊâãÁâåÈï∑Â∫¶ÁÇ∫16ÂºµÔºåÂèØÊ™¢Êü•‰∏ÉÂ∞ç
  if (melds.length === 0 && isSevenPairs(tiles)) return true;
  // ÂâØÈú≤Êï∏Èáè‰ª£Ë°®Â∑≤Á∂ìÂÆåÊàêÁöÑÁµÑÊï∏ÔºåÈÇÑÈúÄË¶ÅÁöÑÁµÑÊï∏ = 5 - ÂâØÈú≤Êï∏
  const neededSets = Math.max(0, 5 - melds.length);
  return canStandardWin(tiles, neededSets);
}

// Ê™¢Êü•ÊòØÂê¶ËÅΩÁâåÔºàÂè™Â∑Æ‰∏ÄÂºµÁâåÂ∞±ËÉΩËÉ°Ôºâ
function isListening(hand, melds) {
  // Ê™¢Êü•ÊòØÂê¶Âè™Â∑Æ‰∏ÄÂºµÁâåÂ∞±ËÉΩËÉ°
  // ÈÅçÊ≠∑ÊâÄÊúâÂèØËÉΩÁöÑÁâåÔºåÁúãÊòØÂê¶ËÉΩËÉ°
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  return allPossibleTiles.some(tile => {
    const testHand = hand.concat([tile]);
    return isWinningNow(testHand, melds, tile);
  });
}

function isSevenPairs(tiles) {
  if (tiles.length !== 16) return false;
  const m = countByKey(tiles);
  const vals = Object.values(m);
  return vals.filter(x => x === 2).length === 8 && vals.every(x => x === 2 || x === 0);
}

function canStandardWin(tiles, need = 5) {
  const counts = countByKey(tiles);
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      if (canSplitMelds(counts, need)) return true;
      counts[k] += 2;
    }
  }
  return false;
}

function canSplitMelds(counts, need) {
  if (need === 0) return Object.values(counts).every(v => v === 0);
  let first = null;
  for (const k in counts) {
    if (counts[k] > 0) {
      first = k;
      break;
    }
  }
  if (!first) return need === 0;
  
  if (counts[first] >= 3) {
    counts[first] -= 3;
    if (canSplitMelds(counts, need - 1)) return true;
    counts[first] += 3;
  }
  
  const s = first[0];
  const v = parseInt(first.slice(1));
  if ((s === SUIT_W || s === SUIT_T || s === SUIT_B) && v <= 7) {
    const k2 = s + (v + 1), k3 = s + (v + 2);
    if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
      counts[first]--;
      counts[k2]--;
      counts[k3]--;
      if (canSplitMelds(counts, need - 1)) return true;
      counts[first]++;
      counts[k2]++;
      counts[k3]++;
    }
  }
  return false;
}

function countByKey(tiles) {
  const m = {};
  for (const t of tiles) {
    const k = tileKey(t);
    m[k] = (m[k] || 0) + 1;
  }
  return m;
}

function tileSortKey(t) {
  const order = { W: 0, T: 1, B: 2, F: 3, D: 4, H: 5 };
  const o = order[t.suit];
  const v = (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) ? t.rank : ({ E: 1, S: 2, W: 3, N: 4, C: 5, F: 6, B: 7 }[t.name] || 0);
  return o * 100 + v;
}

/* ========= AI ÈÇèËºØ ========= */
function shantenAfterRemove(hand) {
  function approxShanten14(tiles) {
    if (isWinningNow(tiles, [], null)) return 0;
    const m = countByKey(tiles);
    let pairs = 0, triples = 0, singles = 0;
    for (const k in m) {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else singles++;
    }
    let est = Math.max(0, 5 - (pairs + triples));
    est += Math.ceil(singles / 4) * 0.5;
    return est;
  }
  
  let best = 99;
  const n = hand.length;
  for (let i = 0; i < n; i++) {
    const take = hand.filter((_, k) => k !== i);
    best = Math.min(best, approxShanten14(take));
  }
  
  const m = countByKey(hand);
  let pairs = 0;
  for (const k in m) {
    pairs += Math.floor(m[k] / 2);
  }
  const sevenNeed = Math.max(0, 8 - pairs);
  return Math.min(best, sevenNeed);
}

function aiChooseDiscard(pid) {
  const me = S.players[pid];
  const visible = [];
  S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
  
  let cands = me.hand.map(t => {
    const after = me.hand.filter(x => x !== t);
    const sh = shantenAfterRemove(after);
    const risk = riskOf(t);
    const score = (-120 * sh) + (-2.0 * risk);
    return { tile: t, score };
  });
  
  cands.sort((a, b) => b.score - a.score);
  return cands[0].tile;
}

function riskOf(tile) {
  if (tile.suit === SUIT_F || tile.suit === SUIT_D) return 0.4;
  if (tile.rank === 1 || tile.rank === 9) return 0.65;
  return 1.0;
}

function keyToTile(k) {
  const s = k[0], v = k.slice(1);
  if (s === 'W' || s === 'T' || s === 'B') return { suit: s, rank: parseInt(v), id: -1 };
  if (s === 'F') return { suit: SUIT_F, name: v, id: -1 };
  if (s === 'D') return { suit: SUIT_D, name: v, id: -1 };
  return { suit: '?', id: -1 };
}

/* ========= ÂêÉÁâå„ÄÅÁ¢∞ÁâåËàáÊßìÁâåÈÇèËºØ ========= */

// ÂêÉÁâåÔºöÂè™ËÉΩÂêÉ‰∏äÂÆ∂ÁöÑÁâåÔºå‰∏îÂè™ËÉΩÂêÉÊï∏Â≠óÁâåÔºàËê¨Á≠íÊ¢ùÔºâ
function canChow(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  
  // Âè™ËÉΩÂêÉ‰∏äÂÆ∂ÁöÑÁâåÔºöÂÉÖ‰∏ã‰∏ÄÂÆ∂ÂèØ‰ª•ÂêÉÔºà‰æãÂ¶ÇÊâìÁâåËÄÖÁÇ∫ pÔºåÂè™Êúâ (p+1)%4 ÂèØ‰ª•ÂêÉÔºâ
  // Áï∂Ââç S.turn ‰ªçÁÇ∫ÊâìÁâåËÄÖÔºåÂú®ÂèçÊáâÊúüÈñìÊú™ËÆäÊõ¥
  const nextPlayer = (S.turn + 1) % 4;
  if (pid !== nextPlayer) return [];
  
  // Âè™ËÉΩÂêÉÊï∏Â≠óÁâå
  if (tile.suit !== SUIT_W && tile.suit !== SUIT_T && tile.suit !== SUIT_B) return [];
  
  const rank = tile.rank;
  const suit = tile.suit;
  const patterns = [];
  
  // Ê™¢Êü•‰∏âÁ®ÆÂêÉÁâåÂûãÊÖãÔºö‰∏äÂêÉ„ÄÅ‰∏≠ÂêÉ„ÄÅ‰∏ãÂêÉ
  // ‰∏äÂêÉÔºöÂêÉÁöÑÁâå + ÂæåÈù¢ÂÖ©Âºµ (‰æãÔºöÂêÉ 1ÔºåÊâãÁâåÊúâ 2,3)
  if (rank <= 7) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 2);
    if (has1 && has2) patterns.push([rank, rank + 1, rank + 2]);
  }
  
  // ‰∏≠ÂêÉÔºöÂêÉÁöÑÁâåÂú®‰∏≠Èñì (‰æãÔºöÂêÉ 2ÔºåÊâãÁâåÊúâ 1,3)
  if (rank >= 2 && rank <= 8) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    if (has1 && has2) patterns.push([rank - 1, rank, rank + 1]);
  }
  
  // ‰∏ãÂêÉÔºöÂêÉÁöÑÁâå + ÂâçÈù¢ÂÖ©Âºµ (‰æãÔºöÂêÉ 3ÔºåÊâãÁâåÊúâ 1,2)
  if (rank >= 3) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 2);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    if (has1 && has2) patterns.push([rank - 2, rank - 1, rank]);
  }
  
  return patterns;
}

function doChow(pid, tile, pattern) {
  const pl = S.players[pid];
  const suit = tile.suit;
  const tiles = [tile];
  
  // ÂæûÊâãÁâå‰∏≠ÁßªÈô§Â∞çÊáâÁöÑÁâå
  pattern.forEach(rank => {
    if (rank !== tile.rank) {
      const idx = pl.hand.findIndex(t => t.suit === suit && t.rank === rank);
      if (idx >= 0) {
        tiles.push(pl.hand.splice(idx, 1)[0]);
      }
    }
  });
  
  // ÊéíÂ∫èÁâåÁµÑ
  tiles.sort((a, b) => a.rank - b.rank);
  
  pl.melds.push({ type: 'chow', tiles });
  // ÂêÉÁâåÂ±¨ÊñºÊòéÁâå
  S.anyOpenMeld = true;
  log(`üçú ${playerName(pid)} ÂêÉ‰∫Ü ${tiles.map(t => keyToText(tileKey(t))).join(' ')}`);
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // Â¶ÇÊûúÊòØÁé©ÂÆ∂ÂêÉÁâåÔºåÊ™¢Êü•ÊòØÂê¶ÂèØÂ†±ËÅΩÔºàÂêÉÁâåÂæåÁ∏ΩÁâåÊï∏ÁÇ∫17 + ÊßìÊï∏Ôºâ
  if (pid === 0) {
    const me = S.players[0];
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

function canPong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 2;
}

function canKong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 3;
}

// Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•ÈÄ≤Ë°åÊöóÊßìÔºöÊâãÁâå‰∏≠ÊúâÂõõÂºµÁõ∏ÂêåÁâå
function canConcealedKong(pid) {
  const pl = S.players[pid];
  const counts = countByKey(pl.hand);
  return Object.keys(counts).filter(k => counts[k] >= 4);
}

// Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•Âä†ÊßìÔºöÂ∑≤Á¢∞ÁöÑÁâå‰∏≠Ëã•Êúâ3ÂºµÁõ∏ÂêåÔºå‰∏îÊâãÁâåË£°ÈÇÑÊúâÁ¨¨4Âºµ
function canAddedKong(pid) {
  const pl = S.players[pid];
  const res = [];
  pl.melds.forEach((m, idx) => {
    if (m.type === 'pong') {
      const k = tileKey(m.tiles[0]);
      // Ê™¢Êü•ÊâãÁâå‰∏≠ÊòØÂê¶ÈÇÑÊúâÂêåÊ®£‰∏ÄÂºµ
      const hasFourth = pl.hand.some(t => tileKey(t) === k);
      if (hasFourth) {
        res.push({ meldIndex: idx, key: k });
      }
    }
  });
  return res;
}

// Âü∑Ë°åÊöóÊßì
function doConcealedKong(pid, key) {
  const pl = S.players[pid];
  // ÂæûÊâãÁâå‰∏≠ÂèñÂá∫ÂõõÂºµÁõ∏ÂêåÁöÑÁâå
  const tiles = [];
  for (let i = pl.hand.length - 1; i >= 0; i--) {
    const t = pl.hand[i];
    if (tileKey(t) === key) {
      tiles.push(pl.hand.splice(i, 1)[0]);
      if (tiles.length === 4) break;
    }
  }
  // Â∞áÊ≠§ÁµÑÂä†ÂÖ•ÂâØÈú≤ÔºåÊ®ôË®òÁÇ∫ÊöóÊßì
  pl.melds.push({ type: 'kong', tiles: tiles, concealed: true });
  S.kongCount++; // ÊßìÁâåÊ¨°Êï∏+1ÔºåÊµ∑Â∫ïÂ§ö‰øùÁïô1Âºµ
  log(`üí• ${playerName(pid)} ÊöóÊßì ${keyToText(key)}`);
  // ÊöóÊßìÂæåÂæûÁéãÁâåË£úÁâå
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  renderAll();
  // Ê™¢Êü•ÊßìÂæåÊòØÂê¶ÂèØ‰ª•Ëá™Êë∏
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    // Áé©ÂÆ∂ÊöóÊßìÂæåÊ™¢Êü•ÊòØÂê¶Ëá™Êë∏
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('‚ú® ‰Ω†ÂèØ‰ª•Ëá™Êë∏ÔºàÊåâ„ÄåËÉ°Áâå„ÄçÔºâÊàñÁπºÁ∫åÂá∫Áâå');
    }
    // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•Â†±ËÅΩ
    if (!pl.declaredListen) {
      const canListenNow = pl.hand.some(tile => {
        const testHand = pl.hand.filter(u => u !== tile);
        return isListening(testHand, pl.melds);
      });
      if (canListenNow) showListenPanel();
    }
  } else {
    // AIÊöóÊßìÂæåÔºåÁõ¥Êé•Ê™¢Êü•Ëá™Êë∏
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    // AIÁπºÁ∫åË°åÂãï
    setTimeout(stepAI, 400);
  }
}

// Âü∑Ë°åÂä†ÊßìÔºöÂ∞áÂ∑≤Á¢∞ÁöÑ‰∏âÂºµÁâåË£úÁÇ∫ÂõõÂºµ
function doAddedKong(pid, meldIndex) {
  const pl = S.players[pid];
  const meld = pl.melds[meldIndex];
  // Â∑≤Á∂ìÊòØÊßìÁâåÁöÑ‰∏çÂÜçÂä†Êßì
  if (!meld || meld.type !== 'pong') return;
  const key = tileKey(meld.tiles[0]);
  // ÂæûÊâãÁâå‰∏≠ÂèñÂá∫Á¨¨4Âºµ
  let idx = -1;
  for (let i = 0; i < pl.hand.length; i++) {
    if (tileKey(pl.hand[i]) === key) {
      idx = i;
      break;
    }
  }
  if (idx < 0) return;
  const tile = pl.hand.splice(idx, 1)[0];
  meld.tiles.push(tile);
  meld.type = 'kong';
  meld.added = true;
  // Âä†Êßì‰ªçÂ±¨ÊòéÁâåÔºåÂ∑≤Á∂ìÂ≠òÂú®Á¢∞
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`üí• ${playerName(pid)} Âä†Êßì ${keyToText(key)}`);
  // ÂæûÁéãÁâåË£úÁâå
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  // Ê®ôË®òÊßì‰∏äÈñãËä±ÊóóÊ®ô
  pl.rinshan = true;
  renderAll();
  // ÊßìÂæåÊ™¢Êü•ÊòØÂê¶Ëá™Êë∏
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('‚ú® ‰Ω†ÂèØ‰ª•Ëá™Êë∏ÔºàÊåâ„ÄåËÉ°Áâå„ÄçÔºâÊàñÁπºÁ∫åÂá∫Áâå');
    }
    // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•Â†±ËÅΩ
    if (!pl.declaredListen) {
      const canListenNow = pl.hand.some(tile2 => {
        const testHand = pl.hand.filter(u => u !== tile2);
        return isListening(testHand, pl.melds);
      });
      if (canListenNow) showListenPanel();
    }
  } else {
    // AI Âä†ÊßìÂæåÊ™¢Êü•Ëá™Êë∏
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 400);
  }
}

function doPong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 2; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'pong', tiles });
  // ÂÅöÁ¢∞Â±¨ÊñºÊòéÁâåÔºåË®≠ÂÆöÂ∑≤Âá∫ÁèæÊòéÂêÉÁ¢∞Êßì
  S.anyOpenMeld = true;
  log(`üî• ${playerName(pid)} Á¢∞‰∫Ü ${keyToText(k)}`);
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // Ëã•ÊòØÁé©ÂÆ∂Á¢∞ÁâåÔºåÊ™¢Êü•ÂêÉÁ¢∞ÂæåÊòØÂê¶ÂèØÂ†±ËÅΩ
  if (pid === 0) {
    const me = S.players[0];
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

function doKong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 3; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'kong', tiles });
  // ÊòéÊßìÂ±¨ÊñºÊòéÁâåÔºåË®òÈåÑÂ∑≤ÈñãÁ¢∞ÂêÉÊßì
  S.anyOpenMeld = true;
  S.kongCount++; // ÊßìÁâåÊ¨°Êï∏+1ÔºåÊµ∑Â∫ïÂ§ö‰øùÁïô1Âºµ
  log(`üí• ${playerName(pid)} Êßì‰∫Ü ${keyToText(k)}ÔºåÂæûÁéãÁâåË£úÁâå`);
  
  // ÊßìÁâåÂæåÂæûÁéãÁâåË£úÁâå
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // Ëã•Áî±Áé©ÂÆ∂ÈÄ≤Ë°åÊòéÊßìÔºåË£úÁâåÂæåÊ™¢Êü•Ëá™Êë∏ÂèäËÅΩÁâå
  if (pid === 0) {
    const me = S.players[0];
    // Ê™¢Êü•Ë£úÁâåÂæåÊòØÂê¶Ëá™Êë∏
    const t = me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('‚ú® ‰Ω†ÂèØ‰ª•Ëá™Êë∏ÔºàÊåâ„ÄåËÉ°Áâå„ÄçÔºâÊàñÁπºÁ∫åÂá∫Áâå');
    }
    // Ê™¢Êü•ÊòØÂê¶ÂèØÂ†±ËÅΩ
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

/* ========= Âá∫ÁâåËàáÂèçÊáâ ========= */
function discard(p, tile) {
  const hand = S.players[p].hand;
  const i = hand.indexOf(tile);
  if (i < 0) return;
  hand.splice(i, 1);
  S.players[p].discards.push(tile);
  S.lastDiscard = { tile, from: p };
  log(`üé¥ ${playerName(p)} ÊâìÂá∫ ${keyToText(tileKey(tile))}`);

  // ÊâìÂá∫ÁâåÂæåÔºåÈùûÊßìË£úÁâåÁöÑËá™Êë∏ÊóóÊ®ôÈáçÁΩÆ
  S.players[p].rinshan = false;
  renderAll();
  
  // Ê™¢Êü•ÂÖ∂‰ªñÁé©ÂÆ∂ÊòØÂê¶ÂèØ‰ª•ËÉ°„ÄÅÁ¢∞„ÄÅÊßì„ÄÅÂêÉÔºàÁ¢∞ÊßìÂÑ™ÂÖàÔºâ
  let reactions = [];
  for (let k = 1; k <= 3; k++) {
    const pid = (p + k) % 4;
    if (pid === p) continue;
    
    if (canWinOn(pid, tile)) {
      reactions.push({ pid, type: 'hu', tile });
    } else if (canKong(pid, tile)) {
      reactions.push({ pid, type: 'kong', tile });
    } else if (canPong(pid, tile)) {
      reactions.push({ pid, type: 'pong', tile });
    } else {
      // ÂêÉÁâåÂÑ™ÂÖàÂ∫¶ÊúÄ‰ΩéÔºåÂè™Êúâ‰∏çËÉΩÁ¢∞ÊßìÊôÇÊâçËÉΩÂêÉ
      const chowPatterns = canChow(pid, tile);
      if (chowPatterns.length > 0) {
        reactions.push({ pid, type: 'chow', tile, patterns: chowPatterns });
      }
    }
  }
  
  if (reactions.length > 0) {
    S.waitReact = reactions;
    if (reactions.some(r => r.pid === 0)) {
      showReactionPanel(reactions.filter(r => r.pid === 0));
    } else {
      setTimeout(() => handleAIReaction(reactions), 800);
    }
  } else {
    S.turn = (S.turn + 1) % 4;
    stepNext();
  }
}

function showReactionPanel(reactions) {
  const panel = document.getElementById('reactionPanel');
  const overlay = document.getElementById('overlay');
  
  // Ê™¢Êü•ÊòØÂê¶Â≠òÂú®ÂêÉÁâå‰∏îÊúâÂ§öÁ®ÆÂêÉÊ≥ï„ÄÇËã•ÊúâÔºåËÆìÁé©ÂÆ∂ÈÅ∏ÊìáÂÖ∑È´îÂêÉÊ≥ï
  const chowReact = reactions.find(r => r.type === 'chow');
  if (chowReact && chowReact.patterns && chowReact.patterns.length > 1) {
    // Â§öÁ®ÆÂêÉÊ≥ïÔºöÈ°ØÁ§∫ÊØèÁ®ÆÂêÉÊ≥ïÁöÑÊåâÈàï
    let html = '<div class="reaction-panel"><h3>üçú ÈÅ∏ÊìáÂêÉÊ≥ï</h3><div class="row">';
    chowReact.patterns.forEach((pat, idx) => {
      // pattern ÁÇ∫‰∏âÂºµÁâåÁöÑ rank Èô£ÂàóÔºõÁÇ∫ÈÅøÂÖçÊéíÂ∫èÊîπËÆäÂéüÈô£ÂàóÔºåË§áË£ΩÂæåÊéíÂ∫èÂÜçÈ°ØÁ§∫
      const patText = [...pat].sort((a, b) => a - b).join(' ');
      html += `<button class="chowOpt" data-idx="${idx}">üçú ${patText}</button>`;
    });
    html += '</div><div class="row"><button id="reactPass">‚è≠Ô∏è ÈÅé</button></div></div>';
    panel.innerHTML = html;
    panel.style.display = 'block';
    overlay.style.display = 'block';
    // Á∂ÅÂÆöÊØèÂÄãÂêÉÊ≥ïÊåâÈàïÁöÑ‰∫ã‰ª∂
    const opts = panel.querySelectorAll('.chowOpt');
    opts.forEach(btn => {
      const idx = parseInt(btn.getAttribute('data-idx'));
      btn.onclick = () => {
        // Ê†πÊìöÈÅ∏ÊìáÁöÑÊ®°ÂºèÂü∑Ë°åÂêÉÁâå
        doChow(chowReact.pid, chowReact.tile, chowReact.patterns[idx]);
      };
    });
    // ÈÅé
    document.getElementById('reactPass').onclick = () => {
      hideReactionPanel();
      S.turn = (S.lastDiscard.from + 1) % 4;
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
    };
    return;
  }

  let html = '<div class="reaction-panel"><h3>‚ö° ÂèØ‰ª•ÈÄ≤Ë°åÁöÑÂãï‰Ωú</h3><div class="row">';
  
  reactions.forEach(r => {
    if (r.type === 'hu') {
      html += '<button id="reactHu">üéâ ËÉ°Áâå</button>';
    } else if (r.type === 'pong') {
      html += '<button id="reactPong">üî• Á¢∞</button>';
    } else if (r.type === 'kong') {
      html += '<button id="reactKong">üí• Êßì</button>';
    } else if (r.type === 'chow') {
      html += '<button id="reactChow">üçú ÂêÉ</button>';
    }
  });
  
  html += '<button id="reactPass">‚è≠Ô∏è ÈÅé</button></div></div>';
  
  panel.innerHTML = html;
  panel.style.display = 'block';
  overlay.style.display = 'block';
  
  if (document.getElementById('reactHu')) {
    document.getElementById('reactHu').onclick = () => {
      const r = reactions.find(x => x.type === 'hu');
      doWin(r.pid, S.lastDiscard.from, r.tile, false);
      hideReactionPanel();
    };
  }
  
  if (document.getElementById('reactPong')) {
    document.getElementById('reactPong').onclick = () => {
      const r = reactions.find(x => x.type === 'pong');
      doPong(r.pid, r.tile);
    };
  }
  
  if (document.getElementById('reactKong')) {
    document.getElementById('reactKong').onclick = () => {
      const r = reactions.find(x => x.type === 'kong');
      doKong(r.pid, r.tile);
    };
  }
  
  if (document.getElementById('reactChow')) {
    document.getElementById('reactChow').onclick = () => {
      const r = reactions.find(x => x.type === 'chow');
      // Âè™Êúâ‰∏ÄÁ®ÆÂêÉÊ≥ïÊôÇÁõ¥Êé•Âü∑Ë°å
      doChow(r.pid, r.tile, r.patterns[0]);
    };
  }
  
  document.getElementById('reactPass').onclick = () => {
    hideReactionPanel();
    S.turn = (S.lastDiscard.from + 1) % 4;
    S.lastDiscard = null;
    S.waitReact = null;
    stepNext();
  };
}

function hideReactionPanel() {
  document.getElementById('reactionPanel').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';
}

// È°ØÁ§∫Â†±ËÅΩÈÅ∏ÊìáÈù¢ÊùøÔºöÁï∂Áé©ÂÆ∂ÂèØ‰ª•ÂÆ£ÂëäËÅΩÁâåÊôÇÔºåÂΩàÂá∫Ê≠§Èù¢ÊùøËÆìÁé©ÂÆ∂ÈÅ∏ÊìáÊòØÂê¶Â†±ËÅΩ
function showListenPanel() {
  const panel = document.getElementById('reactionPanel');
  const overlay = document.getElementById('overlay');
  let html = '<div class="reaction-panel">';
  html += '<h3>üîî ÊòØÂê¶Â†±ËÅΩÔºü</h3>';
  html += '<div class="row">';
  html += '<button id="listenYes">üîî ËÅΩÁâå</button>';
  html += '<button id="listenNo">‚è≠Ô∏è ‰∏çËÅΩ</button>';
  html += '</div></div>';
  panel.innerHTML = html;
  panel.style.display = 'block';
  overlay.style.display = 'block';
  document.getElementById('listenYes').onclick = () => {
    const me = S.players[0];
    if (!me.declaredListen) {
      // Ê®ôË®òÂ∑≤Â†±ËÅΩ
      me.declaredListen = true;
      // Ê™¢Êü•Â§©ËÅΩ/Âú∞ËÅΩ
      updateTianDiTing(0);
      // Ë®òÈåÑÊó•Ë™åÔºåÊ†πÊìöÂ§©ËÅΩ/Âú∞ËÅΩÊàñ‰∏ÄËà¨ËÅΩÁâåÈ°ØÁ§∫‰∏çÂêåË®äÊÅØ
      if (me.tianTing) {
        log('üîî ‰Ω†ÂÆ£ÂëäÂ§©ËÅΩÔºÅËÉ°ÁâåÊôÇÂ§ö ' + RULES.scoring.HeavenReady + ' Âè∞');
      } else if (me.diTing) {
        log('üîî ‰Ω†ÂÆ£ÂëäÂú∞ËÅΩÔºÅËÉ°ÁâåÊôÇÂ§ö ' + RULES.scoring.EarthReady + ' Âè∞');
      } else {
        log('üîî ‰Ω†ÂÆ£ÂëäËÅΩÁâåÔºÅËÉ°ÁâåÊôÇÂ§ö 1 Âè∞');
      }
    }
    hideReactionPanel();
    renderAll();
  };
  document.getElementById('listenNo').onclick = () => {
    hideReactionPanel();
    // Áé©ÂÆ∂ÈÅ∏Êìá‰∏çÂ†±ËÅΩÔºåÁ∂≠ÊåÅÂéüÁãÄÁπºÁ∫åÈÅäÊà≤
  };
}

function handleAIReaction(reactions) {
  const huReact = reactions.find(r => r.type === 'hu');
  if (huReact) {
    doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
    return;
  }
  
  const kongReact = reactions.find(r => r.type === 'kong');
  if (kongReact && Math.random() > 0.6) {
    doKong(kongReact.pid, kongReact.tile);
    setTimeout(stepAI, 600);
    return;
  }
  
  const pongReact = reactions.find(r => r.type === 'pong');
  if (pongReact && Math.random() > 0.7) {
    doPong(pongReact.pid, pongReact.tile);
    setTimeout(stepAI, 600);
    return;
  }
  
  S.turn = (S.lastDiscard.from + 1) % 4;
  S.lastDiscard = null;
  S.waitReact = null;
  stepNext();
}

function canWinOn(pid, tile) {
  const pl = S.players[pid];
  const tmp = pl.hand.concat([tile]);
  return isWinningNow(tmp, pl.melds, tile);
}

function doWin(winner, from, tile, selfDraw) {
  S.winner = winner;
  S.fromPlayer = from;
  S.winTile = tile;
  S.phase = 'end';
  const fan = calcFan(winner, tile, selfDraw);
  const delta = RULES.points.base + fan * RULES.points.perFan;
  
  if (selfDraw) {
    for (let i = 0; i < 4; i++) {
      if (i !== winner) {
        S.players[i].points -= delta;
      }
    }
    S.players[winner].points += delta * 3;
    log(`üéâ ${playerName(winner)} Ëá™Êë∏ ${keyToText(tileKey(tile))}Ôºà${fan}Âè∞Ôºâ‚Üí ÊØèÂÆ∂‰ªò ${delta.toLocaleString()}`);
  } else {
    S.players[from].points -= delta * 3;
    S.players[winner].points += delta * 3;
    log(`üéâ ${playerName(winner)} ÈªûËÉ° ${playerName(from)}Ôºà${keyToText(tileKey(tile))}Ôºå${fan}Âè∞Ôºâ‚Üí ÊîæÊßçËÄÖ‰ªò ${(delta * 3).toLocaleString()}`);
  }
  
  renderAll();

  // Ê∏ÖÈô§Êßì‰∏äÈñãËä±ÂèäÊê∂ÊßìÊóóÊ®ô
  S.players[winner].rinshan = false;
  S.robKong = false;

  // Ê∏ÖÈô§Êßì‰∏äÈñãËä±ÊóóÊ®ô
  S.players[winner].rinshan = false;
  
  for (let i = 0; i < 4; i++) {
    if (S.players[i].points <= 0) {
      log(`‚ö†Ô∏è ${playerName(i)} Á†¥Áî¢ÔºåÈÅäÊà≤ÁµêÊùü`);
      setTimeout(() => showFinalScore(), 1500);
      return;
    }
  }
  
  setTimeout(() => {
    log('‚Äî‚Äî Èñã‰∏ã‰∏ÄÂ±Ä ‚Äî‚Äî');
    startNewHand();
  }, 2500);
}

function calcFan(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  
  if (isSevenPairs(pl.hand.concat([winTile]))) fan += RULES.scoring.SevenPairs;
  
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) fan += RULES.scoring.AllPungs;
  
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1) fan += RULES.scoring.PureOneSuit;
  else if (nz === 2 && honors > 0) fan += RULES.scoring.HalfFlush;
  
  // Ëä±ÁâåÂè∞Êï∏Â∑≤ÁßªÈô§
  
  // Â§©ËÅΩ/Âú∞ËÅΩÊàñÊôÆÈÄöÂ†±ËÅΩÂè∞Êï∏
  // Â§©ËÅΩÊàñÂú∞ËÅΩ‰∏çËàá‰∏ÄËà¨ËÅΩÁâåÈáçË§áË®àÂè∞
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
  } else if (pl.diTing) {
    fan += RULES.scoring.EarthReady;
  } else if (pl.declaredListen) {
    fan += 1;
  }
  
  if (selfDraw) {
    const menqing = pl.melds.length === 0;
    fan += menqing ? RULES.scoring.MenqingSelfDraw : RULES.scoring.SelfDraw;
  }

  // Êê∂ÊßìËÉ°ÁâåÂä†Âè∞
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
  }

  // Êßì‰∏äÈñãËä±Âä†Âè∞ÔºöËã•ÊòØËá™Êë∏‰∏î‰æÜËá™ÊßìÂæåË£úÁâå
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
  }
  
  if (S.rules.gold.enabled) {
    const keys = allTiles.map(tileKey);
    const goldOwned = keys.filter(k => S.goldKeys.includes(k)).length;
    fan += goldOwned * S.rules.gold.perGold;
    if (S.goldKeys.includes(tileKey(winTile))) fan += S.rules.gold.winOnGold;
  }
  
  return Math.max(1, fan);
}

function isAllPungsPossible(counts) {
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      let ok = true;
      for (const kk in counts) {
        if (counts[kk] % 3 !== 0) {
          ok = false;
          break;
        }
      }
      counts[k] += 2;
      if (ok) return true;
    }
  }
  return false;
}

/* ========= ÂõûÂêàÊé®ÈÄ≤ ========= */
function stepNext() {
  renderAll();
  if (S.phase === 'end') return;
  if (S.turn === 0) {
    // Ëº™Âà∞Áé©ÂÆ∂
    const me = S.players[0];
    // Ë®àÁÆóÁé©ÂÆ∂Â∑≤ÊìÅÊúâÁöÑÊßìÁµÑÊï∏
    const kongCount = countKongs(me);
    const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    // Âü∫Êú¨‰∏äÔºåÁé©ÂÆ∂Âú®Êë∏ÁâåÂæåÊáâÊåÅÊúâ base+ÊßìÊï∏ ÂºµÁâåÔºõÂá∫ÁâåÂæåÁÇ∫ base-1+ÊßìÊï∏ ÂºµÁâå
    const base = 17;
    const expectedFull = base + kongCount;
    const expectedEmpty = (base - 1) + kongCount;

    if (totalTiles === expectedFull) {
      // Áé©ÂÆ∂Â∑≤Á∂ìÊåÅÊúâÂÆåÊï¥ÂºµÊï∏Ôºå‰∏çÈúÄÊë∏ÁâåÔºåË´ãÂá∫Áâå
      log('üëâ Ë´ãÈÅ∏ÊìáË¶ÅÊâìÂá∫ÁöÑÁâå');
      renderAll();
      // Ê™¢Êü•ÊòØÂê¶ÂèØÂ†±ËÅΩ‰∏¶Â∞öÊú™ÂÆ£ÂëäÔºåËã•ÂèØÂâáÈ°ØÁ§∫Â†±ËÅΩÈù¢Êùø
      if (!me.declaredListen) {
        const canListenNow = me.hand.some(tile => {
          const testHand = me.hand.filter(t => t !== tile);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    } else if (totalTiles === expectedEmpty) {
      // ÈúÄË¶ÅÊë∏Áâå
      drawTile(0);
      const t = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, t)) {
        document.getElementById('btnHu').disabled = false;
        log('‚ú® ‰Ω†ÂèØ‰ª•Ëá™Êë∏ÔºàÊåâ„ÄåËÉ°Áâå„ÄçÔºâÊàñÁπºÁ∫åÂá∫Áâå');
      }
      renderAll();
      // Ê™¢Êü•Êë∏ÁâåÂæåÊòØÂê¶ÂèØ‰ª•Â†±ËÅΩ
      if (!me.declaredListen) {
        const canListenNow = me.hand.some(tile => {
          const testHand = me.hand.filter(t => t !== tile);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    } else {
      // Áï∞Â∏∏ÁãÄÊ≥ÅÔºåË®òÈåÑÈåØË™§
      log(`‚ö†Ô∏è Áï∞Â∏∏ÔºöÁ∏ΩÁâåÊï∏=${totalTiles}ÔºåÊâãÁâå=${me.hand.length}ÔºåÂâØÈú≤=${me.melds.length}ÁµÑÔºåÊßìÊï∏=${kongCount}`);
      renderAll();
    }
  } else {
    setTimeout(stepAI, 600);
  }
}

function stepAI() {
  if (S.phase === 'end') return;
  const p = S.turn;
  const me = S.players[p];
  // Ê†πÊìöÊßìÊï∏Âà§Êñ∑ÊòØÂê¶ÈúÄË¶ÅÊë∏Áâå
  const kongCount = countKongs(me);
  const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
  const expectedFull = 17 + kongCount;
  const expectedEmpty = 16 + kongCount;
  if (totalTiles === expectedEmpty) {
    // ÈúÄË¶ÅÊë∏Áâå
    drawTile(p);
    if (S.phase === 'end') return;
  } else if (totalTiles !== expectedFull) {
    log(`‚ö†Ô∏è AI Áï∞Â∏∏ÔºöÁ∏ΩÁâåÊï∏=${totalTiles}ÔºåÊâãÁâå=${me.hand.length}ÔºåÂâØÈú≤=${me.melds.length}ÁµÑÔºåÊßìÊï∏=${kongCount}`);
  }
  renderAll();
  // Ê™¢Êü•Ëá™Êë∏ÔºöÂÑ™ÂÖàÊñºÊßìÁâåË°åÁÇ∫
  const lastTile = me.hand[me.hand.length - 1];
  if (isWinningNow(me.hand, me.melds, lastTile)) {
    doWin(p, -1, lastTile, true);
    return;
  }
  // AI Ê™¢Êü•Âä†Êßì
  const aks = canAddedKong(p);
  if (aks.length > 0) {
    // Ê™¢Êü•Êê∂Êßì
    const cand = aks[0];
    const key = cand.key;
    const tile = me.hand.find(t => tileKey(t) === key);
    for (let pid = 0; pid < 4; pid++) {
      if (pid !== p && canWinOn(pid, tile)) {
        S.robKong = true;
        doWin(pid, p, tile, false);
        return;
      }
    }
    doAddedKong(p, cand.meldIndex);
    return;
  }
  // AI Ê™¢Êü•ÊöóÊßì
  const cks = canConcealedKong(p);
  if (cks.length > 0) {
    doConcealedKong(p, cks[0]);
    return;
  }
  // Ê™¢Êü•Ëá™Êë∏ÔºàÂÜçÊ¨°Ê™¢Êü•ÔºåÁêÜË´ñ‰∏äÂú®Âä†ÊßìËàáÊöóÊßìËôïÁêÜÂæåÔºâ
  if (isWinningNow(me.hand, me.melds, lastTile)) {
    doWin(p, -1, lastTile, true);
    return;
  }
  // ‰∏ÄËà¨Âá∫Áâå
  const out = aiChooseDiscard(p);
  setTimeout(() => discard(p, out), 400);
}

/* ========= UI Êìç‰Ωú ========= */

document.getElementById('btnHu').onclick = () => {
  const me = S.players[0];
  const t = me.hand[me.hand.length - 1];
  if (!isWinningNow(me.hand, me.melds, t)) return;
  doWin(0, -1, t, true);
};

document.getElementById('btnListen').onclick = () => {
  const me = S.players[0];
  // Â¶ÇÊûúÂ∑≤Â†±ËÅΩÔºåÁõ¥Êé•ÊèêÈÜí
  if (me.declaredListen) {
    log('‚ö†Ô∏è ‰Ω†Â∑≤Á∂ìÂ†±ËÅΩ‰∫Ü');
    return;
  }
  // Ê™¢Êü•ÊòØÂê¶ÂèØËÅΩÁâåÔºö‰æùÊìöÁõÆÂâçÊâãÁâåÂºµÊï∏ÈÅ∏Êìá‰∏çÂêåÊ™¢Êü•ÊñπÂºè
  const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
  const kongCount = countKongs(me);
  const expectedFull = 17 + kongCount;
  const expectedEmpty = 16 + kongCount;
  let canListen = false;
  if (total === expectedFull) {
    // ÊìÅÊúâÂÆåÊï¥ÂºµÊï∏ÔºöÊâìÂá∫ÂÖ∂‰∏≠‰∏ÄÂºµÂæåÊòØÂê¶ËÅΩÁâå
    canListen = me.hand.some(tile => {
      const testHand = me.hand.filter(t => t !== tile);
      return isListening(testHand, me.melds);
    });
  } else if (total === expectedEmpty) {
    // Â∞ë‰∏ÄÂºµÁöÑÁãÄÊÖãÔºöÁï∂ÂâçÊâãÁâåÊòØÂê¶Â∑≤Á∂ìËÅΩÁâå
    canListen = isListening(me.hand, me.melds);
  } else {
    // ÂÖ∂‰ªñÂºµÊï∏‰∏çÂÖÅË®±Â†±ËÅΩ
    canListen = false;
  }
  if (!canListen) {
    log('‚ö†Ô∏è ‰Ω†ÈÇÑÊ≤íÊúâËÅΩÁâåÔºåÁÑ°Ê≥ïÂ†±ËÅΩ');
    return;
  }
  // È°ØÁ§∫Â†±ËÅΩÁ¢∫Ë™çÈù¢Êùø
  showListenPanel();
};

// Áé©ÂÆ∂Âü∑Ë°åÊöóÊßìÔºàÊâãÁâåÂõõÂºµÁõ∏ÂêåÔºâ
document.getElementById('btnKong').onclick = () => {
  if (S.turn !== 0 || S.phase === 'end' || S.lastDiscard !== null) return;
  const added = canAddedKong(0);
  const concealed = canConcealedKong(0);
  const me = S.players[0];
  // ÂÑ™ÂÖàËôïÁêÜÂä†Êßì
  if (added.length > 0) {
    const cand = added[0];
    const key = cand.key;
    // ÊâæÂá∫ÊâãÁâå‰∏≠ÁöÑÁ¨¨ÂõõÂºµ
    const tile = me.hand.find(t => tileKey(t) === key);
    // Ê™¢Êü•ÊòØÂê¶ÊúâÁé©ÂÆ∂ÂèØ‰ª•Êê∂Êßì
    for (let pid = 1; pid < 4; pid++) {
      if (canWinOn(pid, tile)) {
        // Êê∂ÊßìËÉ°Áâå
        S.robKong = true;
        doWin(pid, 0, tile, false);
        return;
      }
    }
    // ÁÑ°‰∫∫Êê∂ÊßìÔºåÂü∑Ë°åÂä†Êßì
    doAddedKong(0, cand.meldIndex);
    return;
  }
  // Ëã•Ê≤íÊúâÂä†ÊßìÂâáÊ™¢Êü•ÊöóÊßì
  if (concealed.length > 0) {
    const key = concealed[0];
    doConcealedKong(0, key);
    return;
  }
};

document.getElementById('newGameBtn').onclick = () => {
  S = { players: Array.from({ length: 4 }, () => ({ points: RULES.initialPoints })) };
  document.getElementById('log').textContent = '';
  startNewHand(true);
};

function onClickYourTile(idx) {
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  const tile = me.hand[idx];
  discard(0, tile);
}

/* ========= UI Ê∏≤Êüì ========= */
function renderAll() {
  const goldEl = document.getElementById('goldbar');
  if (S.rules.gold.enabled) {
    goldEl.innerHTML = '‚ú® Êú¨Â±ÄÈáëÁâåÔºö ' + S.goldKeys.map(k => `<span class="tilekey">${keyToText(k)}</span>`).join('');
    goldEl.style.display = 'block';
  } else {
    goldEl.style.display = 'none';
  }
  
  const sc = document.getElementById('scoreboard');
  // ÁµÑÂêàÊØèÂÆ∂Áé©ÂÆ∂Ë≥áË®äÔºåÈ°ØÁ§∫ÂêçÁ®±„ÄÅÁ©çÂàÜÂíåÊòØÂê¶Â∑≤Â†±ËÅΩÔºàÂê´Â§©ËÅΩ„ÄÅÂú∞ËÅΩÊ®ôË®òÔºâ
  sc.innerHTML = '<div class="score">' + ['Êù±(‰Ω†)', 'Âçó', 'Ë•ø', 'Âåó'].map((n, i) => {
    const p = S.players[i];
    const cls = (i === S.dealer ? 'dealer' : '');
    const bankrupt = p.points <= 0 ? '<span class="danger">ÔºàÁ†¥Áî¢Ôºâ</span>' : '';
    // ËÅΩÁâåÊ®ôË®òÔºöÂ§©ËÅΩ„ÄÅÂú∞ËÅΩÂÑ™ÂÖàÔºåÂÖ∂Ê¨°ÊôÆÈÄöËÅΩÁâå
    let listenBadge = '';
    if (p.tianTing) {
      listenBadge = '<span class="badge ok">Â§©ËÅΩ</span>';
    } else if (p.diTing) {
      listenBadge = '<span class="badge ok">Âú∞ËÅΩ</span>';
    } else if (p.declaredListen) {
      listenBadge = '<span class="badge ok">ËÅΩ</span>';
    }
    return `<div class="player-info ${cls}">
      <div class="player-name">${n} ${bankrupt} ${listenBadge}</div>
      <div class="player-points">${p.points.toLocaleString()}</div>
    </div>`;
  }).join('') + '</div>';
  
  // Ë®àÁÆóÂâ©È§òÂèØÊë∏ÁâåÊï∏ÔºöÁâåÂ±± - Êµ∑Â∫ï16Âºµ
  const remainDrawable = Math.max(0, S.wall.length);
  
  document.getElementById('roundinfo').innerHTML =
    `<span class="pill">üé¥ Ââ©È§òÁâåÔºö${remainDrawable}</span>
     <span class="pill">üë§ Ëº™Âà∞Ôºö${playerName(S.turn)}</span>`;
  
  const you = S.players[0];
  you.hand.sort((a, b) => tileSortKey(a) - tileSortKey(b));
  
  // ‰∏äÊéí8ÂºµÔºå‰∏ãÊéíÂâ©È§òÁöÑ
  const topRow = you.hand.slice(0, 8);
  const bottomRow = you.hand.slice(8);
  
  let handHTML = '<div class="hand-container">';
  
  // ‰∏äÊéí
  if (topRow.length > 0) {
    handHTML += '<div class="hand-row">';
    topRow.forEach((t, idx) => {
      const k = tileKey(t);
      const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
      const suitClass = `suit-${t.suit}`;
      handHTML += `<div class="tile ${suitClass} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
    });
    handHTML += '</div>';
  }
  
  // ‰∏ãÊéí
  if (bottomRow.length > 0) {
    handHTML += '<div class="hand-row">';
    bottomRow.forEach((t, idx) => {
      const k = tileKey(t);
      const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
      const suitClass = `suit-${t.suit}`;
      const realIdx = 8 + idx;
      // ÊúÄÂæå‰∏ÄÂºµÁâåÁî®ÁâπÊÆäÊ®£ÂºèÊ®ôË®òÔºàÊë∏ÁöÑÁâåÔºâ
      const isLastTile = (realIdx === you.hand.length - 1);
      const drawnClass = isLastTile ? 'tile-drawn' : '';
      handHTML += `<div class="tile ${suitClass} ${drawnClass} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${realIdx})">${keyToText(k)}</div>`;
    });
    handHTML += '</div>';
  }
  
  handHTML += '</div>';
  
  document.getElementById('yourHand').innerHTML = handHTML;
  
  let meldsHTML = '';
  if (you.melds.length > 0) {
    meldsHTML += you.melds.map(m => {
      let type = 'Á¢∞';
      if (m.type === 'kong') type = m.concealed ? 'ÊöóÊßì' : 'Êßì';
      else if (m.type === 'chow') type = 'ÂêÉ';
      return `<div class="meld">${type}Ôºö${m.tiles.map(t => keyToText(tileKey(t))).join(' ')}</div>`;
    }).join('');
  }
  // Ëä±ÁâåÈ°ØÁ§∫Â∑≤ÁßªÈô§
  document.getElementById('yourMelds').innerHTML = meldsHTML;
  
  // Reset the self-draw button state. It will be enabled below if the player
  // just drew a winning tile.
  const btnHu = document.getElementById('btnHu');
  btnHu.disabled = true;
  // Ëã•Ëº™Âà∞Áé©ÂÆ∂‰∏îÈÅäÊà≤Êú™ÁµêÊùüÔºåÊ™¢Êü•ÊúÄËøëÊë∏ÁöÑÁâåÊòØÂê¶ÂΩ¢ÊàêËá™Êë∏Ôºö
  if (S.turn === 0 && S.phase !== 'end') {
    const mePlayer = S.players[0];
    const kongCount = countKongs(mePlayer);
    const total = mePlayer.hand.length + mePlayer.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = 17 + kongCount;
    if (total === expectedFull) {
      const lastTile = mePlayer.hand[mePlayer.hand.length - 1];
      if (isWinningNow(mePlayer.hand, mePlayer.melds, lastTile)) {
        btnHu.disabled = false;
      }
    }
  }
  
  // ËÅΩÁâåÊåâÈàïÔºöÂè™ÊúâËº™Âà∞Áé©ÂÆ∂„ÄÅÊú™Â†±ËÅΩ‰∏îÁ¢∫ÂØ¶ÈÅîÂà∞ËÅΩÁâåÊ¢ù‰ª∂ÊôÇÊâçÂïüÁî®„ÄÇ
  const me = S.players[0];
  let canListenBtn = false;
  if (S.turn === 0 && !me.declaredListen && S.phase !== 'end') {
    const kongCount = countKongs(me);
    const totalTilesMe = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = 17 + kongCount;
    const expectedEmpty = 16 + kongCount;
    // Âá∫ÁâåÁãÄÊÖãÔºöexpectedFullÔºåÊ™¢Êü•ÊâìÂá∫‰ªª‰∏ÄÁâåÂæåÊòØÂê¶ËÅΩÁâå
    if (totalTilesMe === expectedFull) {
      const canListenAfterDiscard = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
      if (canListenAfterDiscard) canListenBtn = true;
    }
    // Êë∏ÁâåÂæåÂæÖÊë∏ÁãÄÊÖãÔºöexpectedEmptyÔºåÊ™¢Êü•ÊâãÁâåÊòØÂê¶Â∑≤Á∂ìËÅΩÁâå
    if (totalTilesMe === expectedEmpty) {
      canListenBtn = isListening(me.hand, me.melds);
    }
  }
  document.getElementById('btnListen').disabled = !canListenBtn;

  // ÊöóÊßìÊåâÈàïÔºöËº™Âà∞Áé©ÂÆ∂ÔºåÁÑ°Ê£ÑÁâåÂèçÊáâÔºå‰∏îÊâãÁâå‰∏≠Â≠òÂú®ÂõõÂºµÁõ∏ÂêåÁâåÊôÇÂïüÁî®
  const btnKong = document.getElementById('btnKong');
  if (S.turn === 0 && S.phase !== 'end' && S.waitReact === null) {
    const cks = canConcealedKong(0);
    const aks = canAddedKong(0);
    btnKong.disabled = (cks.length === 0 && aks.length === 0);
  } else {
    btnKong.disabled = true;
  }
  
  const wrap = document.getElementById('others');
  wrap.innerHTML = [1, 2, 3].map(i => {
    const p = S.players[i];
    const handCount = p.hand.length;
    const disc = p.discards.map(t => keyToText(tileKey(t))).join(' ');
    let extras = '';
    if (p.melds.length > 0) {
      extras += 'ÔΩú' + p.melds.map(m => {
        let type = 'Á¢∞';
        if (m.type === 'kong') type = m.concealed ? 'ÊöóÊßì' : 'Êßì';
        else if (m.type === 'chow') type = 'ÂêÉ';
        return `${type}Ôºö${m.tiles.map(t => keyToText(tileKey(t))).join(' ')}`;
      }).join('„ÄÅ');
    }
    // Ëä±ÁâåÈ°ØÁ§∫Â∑≤ÁßªÈô§
    return `<div class="score">
      <h3>${playerName(i)}</h3>
      <div>üé¥ ÊâãÁâåÊï∏Ôºö${handCount}ÔΩúÊç®ÁâåÔºö${disc || 'ÁÑ°'} ${extras}</div>
    </div>`;
  }).join('');
}

function showFinalScore() {
  S.phase = 'end';
  renderAll();
  
  const rankings = S.players.map((p, i) => ({ name: playerName(i), points: p.points, index: i }))
    .sort((a, b) => b.points - a.points);
  
  let msg = 'üèÜ ÈÅäÊà≤ÁµêÊùüÔºÅÊúÄÁµÇÊàêÁ∏æÔºö\n';
  rankings.forEach((r, rank) => {
    const medals = ['ü•á', 'ü•à', 'ü•â', '4‰Ωç'];
    msg += `${medals[rank]} ${r.name}Ôºö${r.points.toLocaleString()}ÂàÜ\n`;
  });
  
  log(msg);
  log('üîÑ ÈªûÊìä„ÄåÈñãÂßãÊñ∞Â±Ä„ÄçÈáçÊñ∞ÈñãÂßãÈÅäÊà≤');
}

/* ========= ÂïüÂãïÈÅäÊà≤ ========= */
startNewHand(true);
</script>
</body>
</html>

